--!strict
-- RoundedUI: cross-platform UI library with rounded corners and rich controls

local Players = game:GetService("Players")
local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer

local function create(instance, props, children)
    local obj = Instance.new(instance)
    for k, v in pairs(props or {}) do
        obj[k] = v
    end
    for _, child in ipairs(children or {}) do
        child.Parent = obj
    end
    return obj
end

local function addCorner(parent, radius)
    local c = Instance.new("UICorner")
    c.CornerRadius = UDim.new(0, radius or 8)
    c.Parent = parent
    return c
end

local function addStroke(parent, color, thickness, transparency)
    local s = Instance.new("UIStroke")
    s.Color = color or Color3.fromRGB(60, 60, 60)
    s.Thickness = thickness or 1
    s.Transparency = transparency or 0.4
    s.Parent = parent
    return s
end

local function addPadding(parent, pad)
    local p = Instance.new("UIPadding")
    p.PaddingTop = UDim.new(0, pad)
    p.PaddingBottom = UDim.new(0, pad)
    p.PaddingLeft = UDim.new(0, pad)
    p.PaddingRight = UDim.new(0, pad)
    p.Parent = parent
    return p
end

local function withHover(btn, base, hover)
    btn.MouseEnter:Connect(function()
        btn.BackgroundColor3 = hover
    end)
    btn.MouseLeave:Connect(function()
        btn.BackgroundColor3 = base
    end)
end

local function isMobile()
    return UIS.TouchEnabled and not UIS.KeyboardEnabled
end

local Theme = {
    bg = Color3.fromRGB(20, 20, 24),
    panel = Color3.fromRGB(28, 28, 34),
    panel2 = Color3.fromRGB(32, 32, 40),
    stroke = Color3.fromRGB(60, 60, 70),
    accent = Color3.fromRGB(140, 90, 255), -- softer purple accent
    accentDim = Color3.fromRGB(110, 70, 210),
    text = Color3.fromRGB(230, 230, 240),
    textDim = Color3.fromRGB(180, 180, 190),
    good = Color3.fromRGB(90, 200, 120),
    warn = Color3.fromRGB(230, 80, 80),
    control = Color3.fromRGB(45, 45, 55),
    hover = Color3.fromRGB(55, 55, 70),
}

local FONT = Enum.Font.Gotham
local FONT_B = Enum.Font.GothamBold

local RoundedUI = {}

-- Internal: Color picker popup

local function createColorPickerPopup(rootGui, startColor, onApply)
	-- Services
	local Players = game:GetService("Players")
	local UserInputService = game:GetService("UserInputService")
	local GuiService = game:GetService("GuiService")
	local RunService = game:GetService("RunService")

	-- Local player + PlayerGui
	local player = Players.LocalPlayer
	if not player then error("LocalPlayer not available", 2) end
	local playerGui = player:WaitForChild("PlayerGui")

	-- Helpers fallback (use library helpers if present)
	local lib = _G.UI_LIB or {} -- if your lib exposes a global ref, it will be used; otherwise fallbacks below
	local createFn = lib.create or function(className, props, children)
		local obj = Instance.new(className)
		if props then
			for k,v in pairs(props) do
				-- basic safe assignment (skip unknown properties)
				local success, _ = pcall(function() obj[k] = v end)
			end
		end
		if children and type(children) == "table" then
			for _, child in ipairs(children) do
				if child and child.Parent == nil and child:IsA and child:IsA("GuiObject") then
					child.Parent = obj
				end
			end
		end
		return obj
	end
	local addCorner = lib.addCorner or function(gui, radius)
		if not gui then return end
		local uic = Instance.new("UICorner")
		uic.CornerRadius = UDim.new(0, radius or 6)
		uic.Parent = gui
		return uic
	end
	local addStroke = lib.addStroke or function(gui, color, thickness, trans)
		if not gui then return end
		local stroke = Instance.new("UIStroke")
		stroke.Color = color or Color3.fromRGB(0,0,0)
		stroke.Thickness = thickness or 1
		stroke.Transparency = trans or 0
		stroke.Parent = gui
		return stroke
	end
	local withHover = lib.withHover or function() end
	local Theme = lib.Theme or {
		panel = Color3.fromRGB(30,30,30),
		panel2 = Color3.fromRGB(40,40,40),
		stroke = Color3.fromRGB(0,0,0),
		text = Color3.fromRGB(230,230,230),
		textDim = Color3.fromRGB(180,180,180),
		accent = Color3.fromRGB(80,170,255),
		control = Color3.fromRGB(50,50,50),
		warn = Color3.fromRGB(220,80,80),
	}
	local FONT = lib.FONT or Enum.Font.Gotham
	local FONT_B = lib.FONT_B or Enum.Font.GothamBold
	local isMobile = lib.isMobile or function()
		local os = UserInputService.TouchEnabled and not UserInputService.MouseEnabled
		return os
	end

	-- Validate rootGui. If not given or invalid, we will create a dedicated ScreenGui (IgnoreGuiInset = true).
	local shouldCreateScreenGui = false
	if not rootGui or not rootGui:IsA("ScreenGui") then
		shouldCreateScreenGui = true
	end

	-- Create modal ScreenGui to ensure full coverage and to avoid SafeArea issues (IgnoreGuiInset)
	local modalScreenGui
	if shouldCreateScreenGui then
		modalScreenGui = Instance.new("ScreenGui")
		modalScreenGui.Name = "ColorPickerModal"
		modalScreenGui.ResetOnSpawn = false
		-- IgnoreGuiInset makes UI cover safe areas, preventing the 'holes' near topbar/sides.
		-- This is essential to stop clicks passing to topbar elements or leaving unshaded gaps.
		if modalScreenGui.SetIgnoreGuiInset then
			-- Roblox modern property
			modalScreenGui.IgnoreGuiInset = true
		end
		modalScreenGui.Parent = playerGui
		modalScreenGui.DisplayOrder = 9999
	else
		modalScreenGui = rootGui
	end

	-- Modal overlay (blocks input to underlying UI)
	local overlay = createFn("Frame", {
		Name = "CP_Overlay",
		Size = UDim2.fromScale(1,1),
		Position = UDim2.fromScale(0,0),
		BackgroundColor3 = Color3.fromRGB(0,0,0),
		BackgroundTransparency = 0.55, -- semi-opaque
		BorderSizePixel = 0,
		Parent = modalScreenGui,
	})
	-- Ensure overlay blocks input
	overlay.Active = true
	overlay.ClipsDescendants = false

	addCorner(overlay, 0)

	-- Container centered popup (keeps original Brambes layout: color square + vertical Value slider + numeric fields)
	local popupSize = isMobile() and UDim2.new(0.9, 0, 0.78, 0) or UDim2.new(0, 420, 0, 320)
	local popup = createFn("Frame", {
		Name = "CP_Popup",
		Size = popupSize,
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.fromScale(0.5, 0.5), -- center screen
		BackgroundColor3 = Theme.panel,
		BorderSizePixel = 0,
		Parent = overlay,
	})
	addCorner(popup, 12)
	addStroke(popup, Theme.stroke, 1, 0.4)
	popup.ClipsDescendants = false

	-- Layouting inside popup
	local leftColumn = createFn("Frame", {
		Name = "CP_Left",
		BackgroundTransparency = 1,
		Size = UDim2.new(0.65, -12, 1, -24),
		Position = UDim2.new(0,12,0,12),
		Parent = popup,
	})
	local rightColumn = createFn("Frame", {
		Name = "CP_Right",
		BackgroundTransparency = 1,
		Size = UDim2.new(0.35, -12, 1, -24),
		Position = UDim2.new(0.65, 6, 0, 12),
		Parent = popup,
	})

	-- Title
	local title = createFn("TextLabel", {
		Name = "CP_Title",
		Size = UDim2.new(1, -24, 0, 28),
		Position = UDim2.new(0,12,0,6),
		BackgroundTransparency = 1,
		Text = "Color Picker",
		Font = FONT_B,
		TextSize = 18,
		TextColor3 = Theme.text,
		TextXAlignment = Enum.TextXAlignment.Left,
		Parent = popup,
	})
	-- Small subtitle on right (current HEX)
	local hexLabel = createFn("TextLabel", {
		Name = "CP_HexLabel",
		Size = UDim2.new(0.4, 0, 0, 20),
		Position = UDim2.new(0.6, -12, 0, 12),
		BackgroundTransparency = 1,
		Text = "",
		Font = FONT,
		TextSize = 14,
		TextColor3 = Theme.textDim,
		TextXAlignment = Enum.TextXAlignment.Right,
		Parent = popup,
	})

	-- Left column: color square (Hue x Sat) and Value slider to its right
	local colorAreaSize = isMobile() and math.min( leftColumn.AbsoluteSize.X, leftColumn.AbsoluteSize.Y - 20 ) or 220
	-- We can't rely on AbsoluteSize until rendered, so use UDims. Create color area frame:
	local colorArea = createFn("Frame", {
		Name = "CP_ColorArea",
		Size = UDim2.new(0.7, 0, 0.72, 0),
		Position = UDim2.new(0, 0, 0, 36),
		BackgroundColor3 = Theme.panel2,
		Parent = leftColumn,
	})
	addCorner(colorArea, 8)
	addStroke(colorArea, Theme.stroke, 1, 0.4)

	-- Gradient overlay: Hue->Saturation gradient uses a layered UIGradient + ColorRect technique.
	-- Create an ImageLabel for the hue-sat square background (we will update color cursor and gradient on change)
	local colorSquare = createFn("Frame", {
		Name = "CP_ColorSquare",
		Size = UDim2.new(1, -40, 1, 0),
		Position = UDim2.new(0, 0, 0, 0),
		BackgroundColor3 = Color3.fromRGB(255,0,0),
		Parent = colorArea,
	})
	addCorner(colorSquare, 6)
	addStroke(colorSquare, Theme.stroke, 1, 0.4)
	colorSquare.ClipsDescendants = true

	-- Saturation overlay (white -> transparent)
	local satOverlay = Instance.new("UIGradient")
	satOverlay.Rotation = 0
	satOverlay.Parent = colorSquare

	-- Value overlay (black -> transparent vertical)
	local valOverlay = Instance.new("Frame")
	valOverlay.BackgroundTransparency = 1
	valOverlay.Size = UDim2.new(1,0,1,0)
	valOverlay.Parent = colorSquare

	local valGradient = Instance.new("UIGradient")
	valGradient.Rotation = 90
	valGradient.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.new(0,0,0)),
		ColorSequenceKeypoint.new(1, Color3.new(1,1,1)),
	})
	valGradient.Parent = valOverlay

	-- Color cursor (shows current hue/sat selection)
	local colorCursor = createFn("Frame", {
		Name = "CP_ColorCursor",
		Size = UDim2.new(0, 18, 0, 18),
		AnchorPoint = Vector2.new(0.5, 0.5),
		BackgroundColor3 = Color3.new(1,1,1),
		Parent = colorSquare,
	})
	addCorner(colorCursor, 9)
	addStroke(colorCursor, Color3.new(0,0,0), 1, 0.7)
	local innerDot = createFn("Frame", {
		Name = "CP_ColorCursorInner",
		Size = UDim2.new(0, 8, 0, 8),
		AnchorPoint = Vector2.new(0.5, 0.5),
		Position = UDim2.fromScale(0.5, 0.5),
		BackgroundColor3 = Color3.new(0,0,0),
		Parent = colorCursor,
	})
	addCorner(innerDot, 4)

	-- Value slider (vertical) to the right of the color square
	local valueContainer = createFn("Frame", {
		Name = "CP_ValueContainer",
		Size = UDim2.new(0.12, 0, 0.72, 0),
		Position = UDim2.new(0.88, -10, 0, 0),
		BackgroundTransparency = 1,
		Parent = colorArea,
	})
	local valueBar = createFn("Frame", {
		Name = "CP_ValueBar",
		Size = UDim2.new(1,0,1,0),
		BackgroundColor3 = Color3.fromRGB(255,255,255),
		Parent = valueContainer,
	})
	addCorner(valueBar, 6)
	local valueGrip = createFn("Frame", {
		Name = "CP_ValueGrip",
		Size = UDim2.new(1,0,0,6),
		AnchorPoint = Vector2.new(0, 0.5),
		Position = UDim2.new(0, 0.5, 0.5, 0),
		BackgroundColor3 = Theme.control,
		Parent = valueContainer,
	})
	addCorner(valueGrip, 4)
	addStroke(valueGrip, Theme.stroke, 1, 0.6)

	-- Right column: preview, eye drop, numeric boxes, OK/Cancel
	local previewBox = createFn("Frame", {
		Name = "CP_Preview",
		Size = UDim2.new(1,0,0,64),
		BackgroundColor3 = startColor or Color3.new(1,1,1),
		Parent = rightColumn,
	})
	addCorner(previewBox, 8)
	addStroke(previewBox, Theme.stroke, 1, 0.4)

	local eyeDropBtn = createFn("TextButton", {
		Name = "CP_EyeDrop",
		Size = UDim2.new(1,0,0,32),
		Position = UDim2.new(0,0,0,76),
		BackgroundColor3 = Theme.control,
		Text = "Eye drop",
		Font = FONT,
		TextSize = 14,
		TextColor3 = Theme.text,
		Parent = rightColumn,
	})
	addCorner(eyeDropBtn, 6)
	addStroke(eyeDropBtn, Theme.stroke, 1, 0.4)

	local okBtn = createFn("TextButton", {
		Name = "CP_Ok",
		Size = UDim2.new(1,0,0,36),
		Position = UDim2.new(0,0,1,-40),
		BackgroundColor3 = Theme.accent,
		Text = "OK",
		Font = FONT_B,
		TextSize = 16,
		TextColor3 = Theme.text,
		Parent = rightColumn,
	})
	addCorner(okBtn, 8)
	withHover(okBtn, Theme.accent, Theme.panel2)

	local cancelBtn = createFn("TextButton", {
		Name = "CP_Cancel",
		Size = UDim2.new(1,0,0,36),
		Position = UDim2.new(0,0,1,0),
		BackgroundColor3 = Theme.control,
		Text = "Cancel",
		Font = FONT_B,
		TextSize = 16,
		TextColor3 = Theme.text,
		Parent = rightColumn,
	})
	addCorner(cancelBtn, 8)
	withHover(cancelBtn, Theme.control, Theme.panel2)

	-- Numeric input fields (Hue, Sat, Val, R, G, B, HEX)
	local numericFrame = createFn("Frame", {
		Name = "CP_Numeric",
		Size = UDim2.new(1,0,0,138),
		Position = UDim2.new(0,0,0,118),
		BackgroundTransparency = 1,
		Parent = rightColumn,
	})
	-- make helper to create labeled TextBox
	local function makeLabeledBox(parent, name, y, placeholder)
		local cont = createFn("Frame", {
			Name = name .. "_cont",
			Size = UDim2.new(1,0,0,26),
			Position = UDim2.new(0,0,0,y),
			BackgroundTransparency = 1,
			Parent = parent,
		})
		local label = createFn("TextLabel", {
			Name = name .. "_lbl",
			Size = UDim2.new(0.45,0,1,0),
			BackgroundTransparency = 1,
			Text = name,
			Font = FONT,
			TextSize = 14,
			TextColor3 = Theme.textDim,
			TextXAlignment = Enum.TextXAlignment.Left,
			Parent = cont,
		})
		local box = createFn("TextBox", {
			Name = name,
			Size = UDim2.new(0.55, -6, 1, 0),
			Position = UDim2.new(0.45, 6, 0, 0),
			BackgroundColor3 = Theme.panel2,
			TextColor3 = Theme.text,
			Text = "",
			PlaceholderText = placeholder or "",
			ClearTextOnFocus = false,
			Font = FONT,
			TextSize = 14,
			Parent = cont,
		})
		addCorner(box, 6)
		addStroke(box, Theme.stroke, 1, 0.5)
		return box
	end

	local hueBox = makeLabeledBox(numericFrame, "Hue", 0, "0-359")
	local satBox = makeLabeledBox(numericFrame, "Saturation", 28, "0-255")
	local valBox = makeLabeledBox(numericFrame, "Value", 56, "0-255")
	local rBox = makeLabeledBox(numericFrame, "Red", 84, "0-255")
	local gBox = makeLabeledBox(numericFrame, "Green", 112, "0-255")
	local bBox = makeLabeledBox(numericFrame, "Blue", 140, "0-255")
	-- Note: numericFrame size may grow; ensure Y positions fit - we'll manage FocusLost handlers safely.

	-- We'll keep a compact HEX box below preview area instead (single-line)
	local hexBox = createFn("TextBox", {
		Name = "HEX",
		Size = UDim2.new(1,0,0,28),
		Position = UDim2.new(0,0,0,84),
		BackgroundColor3 = Theme.panel2,
		Text = "",
		PlaceholderText = "#RRGGBB",
		ClearTextOnFocus = false,
		Font = FONT,
		TextSize = 14,
		Parent = rightColumn,
	})
	addCorner(hexBox, 6)
	addStroke(hexBox, Theme.stroke, 1, 0.5)

	-- State
	local CP = {}
	CP.hue, CP.sat, CP.val = (startColor or Color3.new(1,0,0)):ToHSV()
	CP.currentColor = startColor or Color3.new(1,0,0)
	CP.active = true
	CP.isUsingEyeDropper = false

	-- Utility: safe pcall Color3.fromHex
	local function fromHexSafe(hex)
		if not hex then return nil end
		hex = tostring(hex):gsub("%s+",""):gsub("#","")
		if #hex ~= 6 then return nil end
		local success, r = pcall(function() return tonumber(hex:sub(1,2),16) end)
		local success2, g = pcall(function() return tonumber(hex:sub(3,4),16) end)
		local success3, b = pcall(function() return tonumber(hex:sub(5,6),16) end)
		if not (r and g and b) then return nil end
		return Color3.fromRGB(r,g,b)
	end

	-- Apply color to preview and fields
	local function updatePreviewAndFields(color)
		if not color then return end
		CP.currentColor = color
		local h,s,v = color:ToHSV()
		CP.hue, CP.sat, CP.val = h, s, v

		-- update color square background (hue) and gradients
		colorSquare.BackgroundColor3 = Color3.fromHSV(h, 1, 1) -- base hue
		satOverlay.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0, Color3.new(1,1,1)),
			ColorSequenceKeypoint.new(1, Color3.new(1,1,1)),
		}
		-- UIGradient doesn't handle alpha stops, so we use ColorSequence and overlay with Value gradient
		-- update value gradient to go from black to transparent->hue color (we emulate by changing value overlay)
		valueBar.BackgroundColor3 = Color3.fromHSV(h, s, 1)
		-- set preview color
		previewBox.BackgroundColor3 = CP.currentColor
		hexLabel.Text = string.format("%s", "#" .. string.upper(tostring(string.format("%02X%02X%02X", math.floor(CP.currentColor.R*255+0.5), math.floor(CP.currentColor.G*255+0.5), math.floor(CP.currentColor.B*255+0.5)))))
		hexBox.Text = "#" .. string.format("%02X%02X%02X", math.floor(CP.currentColor.R*255+0.5), math.floor(CP.currentColor.G*255+0.5), math.floor(CP.currentColor.B*255+0.5))
		-- numeric fields
		if hueBox then hueBox.Text = tostring(math.floor(CP.hue * 359 + 0.5)) end
		if satBox then satBox.Text = tostring(math.floor(CP.sat * 255 + 0.5)) end
		if valBox then valBox.Text = tostring(math.floor(CP.val * 255 + 0.5)) end
		if rBox then rBox.Text = tostring(math.floor(CP.currentColor.R * 255 + 0.5)) end
		if gBox then gBox.Text = tostring(math.floor(CP.currentColor.G * 255 + 0.5)) end
		if bBox then bBox.Text = tostring(math.floor(CP.currentColor.B * 255 + 0.5)) end

		-- update cursors: colorCursor position and valueGrip position
		-- Position color cursor: X = 1 - hue, Y = 1 - sat (keep inside colorSquare)
		local cwPosX = 1 - CP.hue
		local cwPosY = 1 - CP.sat
		colorCursor.Position = UDim2.new(cwPosX, 0, cwPosY, 0)
		-- valueGrip position (vertical)
		valueGrip.Position = UDim2.new(0, 0, 1 - CP.val, 0)
	end

	-- Initial update
	updatePreviewAndFields(CP.currentColor)

	-- Input handling for color square (touch and mouse). We'll use InputBegan + InputChanged pattern to support mobile.
	local draggingColor = false
	local draggingValue = false

	local function sampleColorFromSquare(absX, absY)
		-- compute relative percent inside colorSquare (taking TopbarInset into account)
		local sqPos = colorSquare.AbsolutePosition
		local sqSize = colorSquare.AbsoluteSize
		local topInset = GuiService.TopbarInset and GuiService.TopbarInset.Height or 0
		-- absY passed from GetMouseLocation already includes screen coordinates; adjust nothing further
		local rx = (absX - sqPos.X) / sqSize.X
		local ry = (absY - sqPos.Y - topInset) / sqSize.Y -- adjust for topbar (safe)
		rx = math.clamp(rx, 0, 1)
		ry = math.clamp(ry, 0, 1)
		-- percent_x = 1 - rx -> hue; percent_y = 1 - ry -> sat
		local hue = 1 - rx
		local sat = 1 - ry
		CP.hue = hue
		CP.sat = sat
		CP.currentColor = Color3.fromHSV(CP.hue, CP.sat, CP.val)
		updatePreviewAndFields(CP.currentColor)
	end

	-- Color area inputs
	colorSquare.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			draggingColor = true
			-- consume input so underlying UI won't receive it
			input:GetMouseLocation() -- no-op, ensures input valid
			local loc = UserInputService:GetMouseLocation()
			sampleColorFromSquare(loc.X, loc.Y)
		end
	end)
	-- Track movement
	local colorMoveConn
	colorMoveConn = UserInputService.InputChanged:Connect(function(input)
		if not draggingColor then return end
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			local loc = input.Position or UserInputService:GetMouseLocation()
			sampleColorFromSquare(loc.X, loc.Y)
		end
	end)
	UserInputService.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			draggingColor = false
		end
	end)

	-- Value bar inputs
	local function sampleValueFromBar(absX, absY)
		local barPos = valueContainer.AbsolutePosition
		local barSize = valueContainer.AbsoluteSize
		local topInset = GuiService.TopbarInset and GuiService.TopbarInset.Height or 0
		local ry = (absY - barPos.Y - topInset) / barSize.Y
		ry = math.clamp(ry, 0, 1)
		-- percent = 1 - ry -> val
		CP.val = 1 - ry
		CP.currentColor = Color3.fromHSV(CP.hue, CP.sat, CP.val)
		updatePreviewAndFields(CP.currentColor)
	end

	valueContainer.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			draggingValue = true
			local loc = UserInputService:GetMouseLocation()
			sampleValueFromBar(loc.X, loc.Y)
		end
	end)
	UserInputService.InputChanged:Connect(function(input)
		if not draggingValue then return end
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			local loc = input.Position or UserInputService:GetMouseLocation()
			sampleValueFromBar(loc.X, loc.Y)
		end
	end)
	UserInputService.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			draggingValue = false
		end
	end)

	-- Eye-dropper: similar approach to original, but using RenderStepped to sample frequently
	local eyeConn
	local function cancelEye()
		CP.isUsingEyeDropper = false
		if eyeConn then eyeConn:Disconnect() eyeConn = nil end
		eyeDropBtn.Text = "Eye drop"
		eyeDropBtn.BackgroundColor3 = Theme.control
	end

	local function startEye()
		if CP.isUsingEyeDropper then cancelEye() return end
		CP.isUsingEyeDropper = true
		eyeDropBtn.Text = "Cancel"
		eyeDropBtn.BackgroundColor3 = Theme.warn

		local function onStep()
			if not CP.isUsingEyeDropper then return end
			local mousePos = UserInputService:GetMouseLocation()
			local guiElements = (modalScreenGui or playerGui):GetGuiObjectsAtPosition(mousePos.X, mousePos.Y - (GuiService.TopbarInset and GuiService.TopbarInset.Height or 0))
			local found
			if guiElements and guiElements[1] then
				for _, g in ipairs(guiElements) do
					if g:IsA("GuiObject") and g.BackgroundTransparency < 1 then
						-- prefer visible GUI objects
						found = g.BackgroundColor3
						break
					end
				end
			end
			if not found then
				-- raycast into world
				local cam = workspace.CurrentCamera
				if cam then
					local ray = cam:ScreenPointToRay(mousePos.X, mousePos.Y - (GuiService.TopbarInset and GuiService.TopbarInset.Height or 0))
					local res = workspace:Raycast(ray.Origin, ray.Direction * 500)
					if res and res.Instance and res.Instance:IsA("BasePart") then
						found = res.Instance.Color
					end
				end
			end
			if found then
				CP.currentColor = found
				CP.hue, CP.sat, CP.val = CP.currentColor:ToHSV()
				updatePreviewAndFields(CP.currentColor)
			end
		end

		eyeConn = RunService.RenderStepped:Connect(onStep)

		-- stop eye-dropper on primary click release
		local stopConn
		stopConn = UserInputService.InputEnded:Connect(function(i)
			if i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch then
				if stopConn then stopConn:Disconnect() stopConn = nil end
				cancelEye()
			end
		end)
	end

	eyeDropBtn.Activated:Connect(function()
		if CP.isUsingEyeDropper then cancelEye() else startEye() end
	end)

	-- Numeric inputs handlers (FocusLost)
	local function safeNum(n)
		return tonumber(n) and tonumber(n) or 0
	end

	-- R/G/B box handlers
	local function rgbToColorAndApply()
		local r = math.clamp(math.floor(safeNum(rBox.Text) + 0.5), 0, 255)
		local g = math.clamp(math.floor(safeNum(gBox.Text) + 0.5), 0, 255)
		local b = math.clamp(math.floor(safeNum(bBox.Text) + 0.5), 0, 255)
		local c = Color3.fromRGB(r,g,b)
		CP.currentColor = c
		CP.hue, CP.sat, CP.val = c:ToHSV()
		updatePreviewAndFields(c)
	end
	rBox.FocusLost:Connect(function() pcall(rgbToColorAndApply) end)
	gBox.FocusLost:Connect(function() pcall(rgbToColorAndApply) end)
	bBox.FocusLost:Connect(function() pcall(rgbToColorAndApply) end)

	-- Hue / Sat / Value boxes handlers
	hueBox.FocusLost:Connect(function()
		local val = math.clamp(math.floor(safeNum(hueBox.Text) + 0.5), 0, 359)
		CP.hue = val / 359
		CP.currentColor = Color3.fromHSV(CP.hue, CP.sat, CP.val)
		updatePreviewAndFields(CP.currentColor)
	end)
	satBox.FocusLost:Connect(function()
		local val = math.clamp(math.floor(safeNum(satBox.Text) + 0.5), 0, 255) / 255
		CP.sat = val
		CP.currentColor = Color3.fromHSV(CP.hue, CP.sat, CP.val)
		updatePreviewAndFields(CP.currentColor)
	end)
	valBox.FocusLost:Connect(function()
		local val = math.clamp(math.floor(safeNum(valBox.Text) + 0.5), 0, 255) / 255
		CP.val = val
		CP.currentColor = Color3.fromHSV(CP.hue, CP.sat, CP.val)
		updatePreviewAndFields(CP.currentColor)
	end)

	-- HEX box
	hexBox.FocusLost:Connect(function()
		local c = fromHexSafe(hexBox.Text)
		if c then
			CP.currentColor = c
			CP.hue, CP.sat, CP.val = c:ToHSV()
			updatePreviewAndFields(c)
		else
			updatePreviewAndFields(CP.currentColor) -- revert invalid hex
		end
	end)

	-- OK and Cancel actions
	okBtn.Activated:Connect(function()
		-- if eye-dropper active, ignore apply
		if CP.isUsingEyeDropper then return end
		if type(onApply) == "function" then
			pcall(function() onApply(CP.currentColor) end)
		end
		CP.active = false
		overlay:Destroy()
		if shouldCreateScreenGui and modalScreenGui and modalScreenGui.Parent == playerGui then
			modalScreenGui:Destroy()
		end
	end)

	cancelBtn.Activated:Connect(function()
		-- cancel resets to startColor
		CP.active = false
		overlay:Destroy()
		if shouldCreateScreenGui and modalScreenGui and modalScreenGui.Parent == playerGui then
			modalScreenGui:Destroy()
		end
	end)

	-- Prevent clicks from passing to underlying UI: we already used a modal overlay Frame that is Active = true.
	-- Additional safety: listen for input on overlay and consume it.
	overlay.InputBegan:Connect(function(input)
		-- consume left click, touch, right click, scroll, or keyboard input while modal is active
		if not CP.active then return end
		local t = input.UserInputType
		if t == Enum.UserInputType.MouseButton1 or t == Enum.UserInputType.Touch or t == Enum.UserInputType.MouseButton2 then
			-- do nothing (consumed)
		end
	end)

	-- If the popup's size/position may need to respond to screen resizing (mobile rotation), update center and sizes
	local function onResized()
		-- keep popup centered
		popup.AnchorPoint = Vector2.new(0.5, 0.5)
		popup.Position = UDim2.fromScale(0.5, 0.5)
		-- scale sizes a bit for mobile
		if isMobile() then
			popup.Size = UDim2.new(0.92, 0, 0.78, 0)
		else
			popup.Size = popupSize
		end
	end
	local resizeConn = nil
	resizeConn = workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
		-- sometimes camera change affects UI scaling; simply recenter
		onResized()
	end)
	UserInputService.WindowSizeChanged:Connect(onResized)
	onResized()

	-- expose a simple table for debug if needed
	return {
		Close = function()
			if overlay and overlay.Parent then
				overlay:Destroy()
			end
			if resizeConn then resizeConn:Disconnect() resizeConn = nil end
		end,
		GetColor = function() return CP.currentColor end,
		SetColor = function(c) if typeof(c) == "Color3" then updatePreviewAndFields(c) end end,
	}
end

UI.createColorPickerPopup = createColorPickerPopup

-- API: Window -> Tabs -> UnderSections -> Controls
function RoundedUI.CreateWindow(nameLeft: string, nameRight: string)
    local gui = create("ScreenGui", {
        Name = "RoundedUI",
        ResetOnSpawn = false,
        IgnoreGuiInset = false,
        ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
    }, {})
    gui.Parent = LocalPlayer:WaitForChild("PlayerGui")

    local window = create("Frame", {
        Name = "Window",
        Size = UDim2.new(isMobile() and 0.95 or 0.6, 0, isMobile() and 0.8 or 0.7, 0),
        Position = UDim2.new(0.5, 0, 0.5, 0),
        AnchorPoint = Vector2.new(0.5, 0.5),
        BackgroundColor3 = Theme.bg,
    }, {})
    window.Parent = gui
    addCorner(window, 12)
    addStroke(window, Theme.stroke, 1, 0.6)
    addPadding(window, 10)

    -- Header
    local header = create("Frame", {
        Name = "Header",
        Size = UDim2.new(1, 0, 0, 32),
        BackgroundColor3 = Theme.panel,
    }, {})
    header.Parent = window
    addCorner(header, 10)
    addStroke(header, Theme.stroke, 1, 0.6)

    local leftTitle = create("TextLabel", {
        Size = UDim2.new(0.5, -8, 1, 0),
        Position = UDim2.new(0, 8, 0, 0),
        BackgroundTransparency = 1,
        Text = nameLeft or "UI",
        TextColor3 = Theme.text,
        Font = FONT_B,
        TextSize = 16,
        TextXAlignment = Enum.TextXAlignment.Left,
    }, {})
    leftTitle.Parent = header

    local rightTitle = create("TextLabel", {
        Size = UDim2.new(0.5, -8, 1, 0),
        Position = UDim2.new(0.5, 0, 0, 0),
        BackgroundTransparency = 1,
        Text = nameRight or "",
        TextColor3 = Theme.textDim,
        Font = FONT,
        TextSize = 14,
        TextXAlignment = Enum.TextXAlignment.Right,
    }, {})
    rightTitle.Parent = header

    -- Tabs strip
	do
    local dragging = false
    local dragStart
    local startPos

    header.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = window.Position
        end
    end)

    UIS.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local delta = input.Position - dragStart
            window.Position = UDim2.new(
                startPos.X.Scale, startPos.X.Offset + delta.X,
                startPos.Y.Scale, startPos.Y.Offset + delta.Y
            )
        end
    end)

    UIS.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
        end
    end)
end

    local tabsStrip = create("ScrollingFrame", {
        Name = "Tabs",
        Size = UDim2.new(1, 0, 0, 44),
        Position = UDim2.new(0, 0, 0, 40),
        BackgroundColor3 = Theme.panel2,
        ScrollBarThickness = 4,
        ScrollingDirection = Enum.ScrollingDirection.X,
        CanvasSize = UDim2.new(0, 0, 0, 0),
    }, {})
    tabsStrip.Parent = window
    addCorner(tabsStrip, 10)
    addStroke(tabsStrip, Theme.stroke, 1, 0.5)
    addPadding(tabsStrip, 6)

    local tabsLayout = Instance.new("UIListLayout")
    tabsLayout.FillDirection = Enum.FillDirection.Horizontal
    tabsLayout.Padding = UDim.new(0, 6)
    tabsLayout.Parent = tabsStrip

    -- Content area
    local content = create("Frame", {
        Name = "Content",
        Size = UDim2.new(1, 0, 1, -80),
        Position = UDim2.new(0, 0, 0, 80),
        BackgroundColor3 = Theme.bg,
    }, {})
    content.Parent = window
    addPadding(content, 6)

    local api = {}

    local tabs = {}

    local function recalcTabsCanvas()
        local total = 0
        for _, child in ipairs(tabsStrip:GetChildren()) do
            if child:IsA("GuiObject") then
                total = total + child.AbsoluteSize.X + 6
            end
        end
        tabsStrip.CanvasSize = UDim2.new(0, total, 0, 0)
    end

    function api:AddSection(tabName: string)
        -- Tab button
        local btn = create("TextButton", {
            Size = UDim2.new(0, 120, 1, -12),
            BackgroundColor3 = Theme.control,
            Text = tabName,
            TextColor3 = Theme.text,
            Font = FONT_B,
            TextSize = 16,
        }, {})
        addCorner(btn, 8)
        withHover(btn, Theme.control, Theme.hover)
        btn.Parent = tabsStrip

        -- Tab page
        local page = create("Frame", {
            Size = UDim2.new(1, 0, 1, 0),
            BackgroundTransparency = 1,
            Visible = (#tabs == 0),
        }, {})
        page.Parent = content

        tabs[tabName] = {button=btn, page=page}

        -- Switch tab on click
        btn.MouseButton1Click:Connect(function()
            for name, data in pairs(tabs) do
    data.page.Visible = (name == tabName)
    data.button.BackgroundColor3 = (name == tabName) and Theme.accent or Theme.control
    data.button.Font = (name == tabName) and FONT_B or FONT
end

            -- Внутри btn.MouseButton1Click:Connect(function() ... end)
for name, data in pairs(tabs) do
    data.page.Visible = (name == tabName)
    data.button.BackgroundColor3 = (name == tabName) and Theme.accent or Theme.control
    data.button.Font = (name == tabName) and FONT_B or FONT
end
-- УДАЛИТЬ строку: leftTitle.Text = tabName

        end)

        -- UnderSections container (two columns)
        local container = create("Frame", {
            Size = UDim2.new(1, 0, 1, 0),
            BackgroundTransparency = 1,
        }, {})
        container.Parent = page

        local columns = create("Frame", {
            Size = UDim2.new(1, 0, 1, 0),
            BackgroundTransparency = 1,
        }, {})
        columns.Parent = container

        local leftCol = create("ScrollingFrame", {
            Size = UDim2.new(0.5, -6, 1, 0),
            BackgroundTransparency = 1,
            ScrollBarThickness = 6,
        }, {})
        leftCol.Parent = columns

        local rightCol = create("ScrollingFrame", {
            Size = UDim2.new(0.5, -6, 1, 0),
            Position = UDim2.new(0.5, 6, 0, 0),
            BackgroundTransparency = 1,
            ScrollBarThickness = 6,
        }, {})
        rightCol.Parent = columns
leftCol.AutomaticCanvasSize = Enum.AutomaticSize.Y
rightCol.AutomaticCanvasSize = Enum.AutomaticSize.Y

        local function makeSection(parentCol, sectionName)
		local openPopup -- единственный открытый попап в секции

local function closePopup()
    if openPopup and openPopup.Parent then
        openPopup:Destroy()
    end
    openPopup = nil
end

-- Закрывать попап при скролле колонны


		
            local sec = create("Frame", {
                Size = UDim2.new(1, -6, 0, 40),
                BackgroundColor3 = Theme.panel,
            }, {})
            sec.Parent = parentCol
            addCorner(sec, 10)
            addStroke(sec, Theme.stroke, 1, 0.6)
            addPadding(sec, 8)

            local title = create("TextLabel", {
                Size = UDim2.new(1, 0, 0, 20),
                BackgroundTransparency = 1,
                Text = sectionName or "",
                TextColor3 = Theme.text,
                Font = FONT_B,
                TextSize = 15,
                TextXAlignment = Enum.TextXAlignment.Left,
            }, {})
            title.Parent = sec

            local stack = create("Frame", {
                Size = UDim2.new(1, 0, 0, 0),
                Position = UDim2.new(0, 0, 0, 24),
                BackgroundTransparency = 1,
            }, {})
            stack.Parent = sec

            local list = Instance.new("UIListLayout")
            list.Padding = UDim.new(0, 6)
            list.FillDirection = Enum.FillDirection.Vertical
            list.SortOrder = Enum.SortOrder.LayoutOrder
            list.Parent = stack

            local function resize()
                sec.Size = UDim2.new(1, -6, 0, 24 + stack.AbsoluteSize.Y + 12)
                
            end
            stack.Changed:Connect(resize)
            RunService.RenderStepped:Connect(resize)

            local sectionAPI = {}

            function sectionAPI:Label(text, opts)
    opts = opts or {}
    local topMargin = opts.topMargin or 6
    local align = opts.align or Enum.TextXAlignment.Left
    local bold = opts.bold or false
    local size = opts.size or 14
    local color = opts.color or Theme.textDim

    local spacer = create("Frame", {
        Size = UDim2.new(1, 0, 0, topMargin),
        BackgroundTransparency = 1,
    }, {})
    spacer.Parent = stack

    local lbl = create("TextLabel", {
        Size = UDim2.new(1, 0, 0, size + 2),
        BackgroundTransparency = 1,
        Text = text,
        TextColor3 = color,
        Font = bold and FONT_B or FONT,
        TextSize = size,
        TextXAlignment = align,
    }, {})
    lbl.Parent = stack
    return lbl
end

function sectionAPI:ToggleWithBind(text, opts)
    opts = opts or {}
    local state = opts.Default or false
    local bindKey: Enum.KeyCode = opts.Bind or Enum.KeyCode.F
    local onToggle = opts.Callback
    local onTrigger = opts.Trigger -- вызывается при нажатии бинда (опционально)

    local row = create("Frame", {
        Size = UDim2.new(1, 0, 0, 34),
        BackgroundTransparency = 1,
    }, {})
    row.Parent = stack

    -- toggle box
    local box = create("TextButton", {
        Size = UDim2.new(0, 28, 0, 28),
        BackgroundColor3 = state and Theme.accent or Theme.control,
        Text = "",
        Position = UDim2.new(0, 0, 0, 3),
    }, {})
    addCorner(box, 6)
    addStroke(box, Theme.stroke, 1, 0.5)
    box.Parent = row

    local lbl = create("TextLabel", {
        Size = UDim2.new(0.55, 0, 1, 0),
        Position = UDim2.new(0, 36, 0, 0),
        BackgroundTransparency = 1,
        Text = text,
        TextColor3 = Theme.text,
        Font = FONT,
        TextSize = 14,
        TextXAlignment = Enum.TextXAlignment.Left,
    }, {})
    lbl.Parent = row

    local keyBtn = create("TextButton", {
        Size = UDim2.new(0.35, -6, 1, 0),
        Position = UDim2.new(0.65, 6, 0, 0),
        BackgroundColor3 = Theme.control,
        TextColor3 = Theme.text,
        Font = FONT_B,
        TextSize = 14,
        TextXAlignment = Enum.TextXAlignment.Center,
        Text = bindKey.Name,
    }, {})
    addCorner(keyBtn, 8)
    addStroke(keyBtn, Theme.stroke, 1, 0.5)
    keyBtn.Parent = row

    local recording = false
    local function setState(val)
        state = val
        box.BackgroundColor3 = state and Theme.accent or Theme.control
        if onToggle then onToggle(state, bindKey) end
    end

    box.MouseButton1Click:Connect(function()
        setState(not state)
    end)

    keyBtn.MouseButton1Click:Connect(function()
        recording = true
        keyBtn.Text = "Press key..."
        keyBtn.BackgroundColor3 = Theme.accentDim
    end)

    UIS.InputBegan:Connect(function(input, gp)
        if gp then return end
        if recording and input.UserInputType == Enum.UserInputType.Keyboard then
            bindKey = input.KeyCode
            keyBtn.Text = bindKey.Name
            keyBtn.BackgroundColor3 = Theme.control
            recording = false
        elseif input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == bindKey then
            -- триггер по бинде
            setState(not state)
            if onTrigger then onTrigger(state, bindKey) end
        end
    end)

    return {
        Set = setState,
        Get = function() return state end,
        SetBind = function(newKey)
            bindKey = newKey
            keyBtn.Text = bindKey.Name
        end
    }
end


            function sectionAPI:Separator()
                local sep = create("Frame", {
                    Size = UDim2.new(1, 0, 0, 1),
                    BackgroundColor3 = Theme.stroke,
                }, {})
                sep.Parent = stack
                return sep
            end

            function sectionAPI:Button(text, callback)
                local btn = create("TextButton", {
                    Size = UDim2.new(1, 0, 0, 34),
                    BackgroundColor3 = Theme.control,
                    Text = text,
                    TextColor3 = Theme.text,
                    Font = FONT_B,
                    TextSize = 14,
                }, {})
                addCorner(btn, 8)
                withHover(btn, Theme.control, Theme.hover)
                btn.Parent = stack
                btn.MouseButton1Click:Connect(function()
                    if callback then callback() end
                end)
                return btn
            end

            function sectionAPI:Toggle(text, opts)
                local state = (opts and opts.Default) or false
                local row = create("Frame", {
                    Size = UDim2.new(1, 0, 0, 34),
                    BackgroundTransparency = 1,
                }, {})
                row.Parent = stack

                local box = create("TextButton", {
                    Size = UDim2.new(0, 28, 0, 28),
                    BackgroundColor3 = state and Theme.accent or Theme.control,
                    Text = "",
                    TextColor3 = Theme.text,
                    Font = FONT_B,
                    TextSize = 14,
                    Position = UDim2.new(0, 0, 0, 3),
                }, {})
                addCorner(box, 6)
                addStroke(box, Theme.stroke, 1, 0.5)
                box.Parent = row

                local lbl = create("TextLabel", {
                    Size = UDim2.new(1, -36, 1, 0),
                    Position = UDim2.new(0, 36, 0, 0),
                    BackgroundTransparency = 1,
                    Text = text,
                    TextColor3 = Theme.text,
                    Font = FONT,
                    TextSize = 14,
                    TextXAlignment = Enum.TextXAlignment.Left,
                }, {})
                lbl.Parent = row

                local function set(val)
                    state = val
                    box.BackgroundColor3 = state and Theme.accent or Theme.control
                    if opts and opts.Callback then opts.Callback(state) end
                end

                box.MouseButton1Click:Connect(function()
                    set(not state)
                end)
                return {
                    Set = set,
                    Get = function() return state end
                }
            end

            function sectionAPI:ToggleBind(text, opts)
                local bindKey: Enum.KeyCode? = (opts and opts.Bind) or Enum.KeyCode.R
                local toggle = sectionAPI:Toggle(text, {Default = (opts and opts.Default) or false, Callback = (opts and opts.Callback)})
                local hint = sectionAPI:Label(("Bind: %s"):format(tostring(bindKey)))
                hint.TextColor3 = Theme.textDim

                UIS.InputBegan:Connect(function(input, gp)
                    if gp then return end
                    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == bindKey then
                        toggle.Set(not toggle.Get())
                    end
                end)

                return {
                    Set = toggle.Set,
                    Get = toggle.Get,
                    SetBind = function(newKey)
                        bindKey = newKey
                        hint.Text = ("Bind: %s"):format(tostring(bindKey))
                    end
                }
            end

function sectionAPI:Slider(text, cfg, callback)
    local min = cfg.min or 0
    local max = cfg.max or 100
    local value = cfg.default or min
    local suffix = cfg.suffix or ""
    local showPercent = cfg.showPercent or false
    local showReset = (cfg.showReset ~= false)

    local container = create("Frame", {
        Size = UDim2.new(1, 0, 0, 72),
        BackgroundTransparency = 1,
    }, {})
    container.Parent = stack

    local top = create("TextLabel", {
        Size = UDim2.new(1, 0, 0, 20),
        BackgroundTransparency = 1,
        Text = ("%s: %s%s"):format(text, tostring(value), suffix),
        TextColor3 = Theme.text,
        Font = FONT,
        TextSize = 14,
        TextXAlignment = Enum.TextXAlignment.Left,
    }, {})
    top.Parent = container

    local bar = create("Frame", {
        Size = UDim2.new(1, 0, 0, 18),
        Position = UDim2.new(0, 0, 0, 26),
        BackgroundColor3 = Theme.control,
    }, {})
    addCorner(bar, 8)
    bar.Parent = container

    local fill = create("Frame", {
        Size = UDim2.new((value - min) / (max - min), 0, 1, 0),
        BackgroundColor3 = Theme.accent,
    }, {})
    addCorner(fill, 8)
    fill.Parent = bar

    -- forward declare
    local set

    -- define set BEFORE any handler uses it
    set = function(v)
        value = math.clamp(v, min, max)
        local rel = (value - min) / (max - min)
        fill.Size = UDim2.new(rel, 0, 1, 0)

        if showPercent then
            local pct = math.floor(rel * 100 + 0.5)
            top.Text = ("%s: %d%%"):format(text, pct)
        else
            local display = string.format("%.2f", value):gsub(",", "")
            top.Text = ("%s: %s%s"):format(text, display, suffix)
        end

        if callback then callback(value) end
    end

    -- Reset row (optional)
    if showReset then
        local resetBtn = create("TextButton", {
            Size = UDim2.new(0, 64, 0, 20),
            BackgroundColor3 = Theme.control,
            Text = "Reset",
            TextColor3 = Theme.text,
            Font = FONT_B,
            TextSize = 12,
        }, {})
        addCorner(resetBtn, 6)
        withHover(resetBtn, Theme.control, Theme.hover)

        local actionsRow = create("Frame", {
            Size = UDim2.new(1, 0, 0, 24),
            Position = UDim2.new(0, 0, 0, 46),
            BackgroundTransparency = 1,
        }, {})
        actionsRow.Parent = container

        resetBtn.Parent = actionsRow
        resetBtn.Position = UDim2.new(1, -68, 0, 2)

        resetBtn.MouseButton1Click:Connect(function()
            -- guard: set exists now
            set(cfg.default or min)
        end)
    end

    bar.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            local conn
            conn = UIS.InputChanged:Connect(function(ch)
                if ch.UserInputType == Enum.UserInputType.MouseMovement or ch.UserInputType == Enum.UserInputType.Touch then
                    local rel = math.clamp((ch.Position.X - bar.AbsolutePosition.X) / bar.AbsoluteSize.X, 0, 1)
                    set(min + (max - min) * rel)
                end
            end)
            UIS.InputEnded:Connect(function(endInput)
                if endInput.UserInputType == input.UserInputType then
                    if conn then conn:Disconnect() end
                end
            end)
        end
    end)

    return {
        Set = set,
        Get = function() return value end
    }
end


function sectionAPI:DropDown(text, options, default, callback)
    local container = create("Frame", {
        Size = UDim2.new(1, 0, 0, 56),
        BackgroundTransparency = 1,
    }, {})
    container.Parent = stack

    local lbl = create("TextLabel", {
        Size = UDim2.new(1, 0, 0, 20),
        BackgroundTransparency = 1,
        Text = text,
        TextColor3 = Theme.text,
        Font = FONT,
        TextSize = 14,
        TextXAlignment = Enum.TextXAlignment.Left,
    }, {})
    lbl.Parent = container

    local current = default or options[1]
    local btn = create("TextButton", {
        Size = UDim2.new(1, 0, 0, 28),
        Position = UDim2.new(0, 0, 0, 24),
        BackgroundColor3 = Theme.control,
        Text = tostring(current),
        TextColor3 = Theme.text,
        Font = FONT,
        TextSize = 14,
        ZIndex = 5,
    }, {})
    addCorner(btn, 8)
    addStroke(btn, Theme.stroke, 1, 0.5)
    btn.Parent = container

    local function open()
        if openPopup then closePopup() end

        local rootGui = stack:FindFirstAncestorOfClass("ScreenGui")
        local overlay = create("TextButton", {
            Size = UDim2.fromScale(1,1),
            BackgroundTransparency = 1,
            Text = "",
            ZIndex = 200,
        }, {})
        overlay.Parent = rootGui

        local popup = create("Frame", {
            Size = UDim2.new(0, btn.AbsoluteSize.X, 0, math.min(#options * 26, 150)),
            Position = UDim2.new(0, btn.AbsolutePosition.X, 0, btn.AbsolutePosition.Y + btn.AbsoluteSize.Y),
            BackgroundColor3 = Theme.panel2,
            ZIndex = 201,
        }, {})
        addCorner(popup, 8)
        addStroke(popup, Theme.stroke, 1, 0.5)
        popup.Parent = rootGui

        local scroll = create("ScrollingFrame", {
            Size = UDim2.new(1, 0, 1, 0),
            BackgroundTransparency = 1,
            ScrollBarThickness = 6,
            CanvasSize = UDim2.new(0, 0, 0, #options * 26),
            ZIndex = 202,
        }, {})
        scroll.Parent = popup

        local layout = Instance.new("UIListLayout")
        layout.Padding = UDim.new(0, 4)
        layout.Parent = scroll

        for _, opt in ipairs(options) do
            local item = create("TextButton", {
                Size = UDim2.new(1, -8, 0, 24),
                BackgroundColor3 = Theme.control,
                Text = tostring(opt),
                TextColor3 = Theme.text,
                Font = FONT,
                TextSize = 14,
                ZIndex = 203,
            }, {})
            addCorner(item, 6)
            item.Parent = scroll

            item.MouseButton1Click:Connect(function()
                current = opt
                btn.Text = tostring(current)
                if callback then callback(current) end
                overlay:Destroy()
                popup:Destroy()
                openPopup = nil
            end)
        end

        overlay.MouseButton1Click:Connect(function()
            overlay:Destroy()
            popup:Destroy()
            openPopup = nil
        end)

        openPopup = popup
    end

    btn.MouseButton1Click:Connect(function()
        if openPopup then
            openPopup:Destroy()
            openPopup = nil
        else
            open()
        end
    end)

    return {
        Get = function() return current end,
        Set = function(val)
            if table.find(options, val) then
                current = val
                btn.Text = tostring(current)
                if callback then callback(current) end
            end
        end
    }
end

function sectionAPI:List(text, options, callback)
    local container = create("Frame", {
        Size = UDim2.new(1, 0, 0, 56),
        BackgroundTransparency = 1,
    }, {})
    container.Parent = stack

    local lbl = create("TextLabel", {
        Size = UDim2.new(1, 0, 0, 20),
        BackgroundTransparency = 1,
        Text = text,
        TextColor3 = Theme.text,
        Font = FONT,
        TextSize = 14,
        TextXAlignment = Enum.TextXAlignment.Left,
    }, {})
    lbl.Parent = container

    local statusText = "Choose..."
    local btn = create("TextButton", {
        Size = UDim2.new(1, 0, 0, 28),
        Position = UDim2.new(0, 0, 0, 24),
        BackgroundColor3 = Theme.control,
        Text = statusText,
        TextColor3 = Theme.text,
        Font = FONT,
        TextSize = 14,
        ZIndex = 5,
    }, {})
    addCorner(btn, 8)
    addStroke(btn, Theme.stroke, 1, 0.5)
    btn.Parent = container

    local selected = {}
    local function updateStatus()
        local keys = {}
        for name, on in pairs(selected) do
            if on then table.insert(keys, name) end
        end
        btn.Text = (#keys > 0) and table.concat(keys, ", ") or statusText
    end

    local function open()
        if openPopup then closePopup() end

        local rootGui = stack:FindFirstAncestorOfClass("ScreenGui")
        local overlay = create("TextButton", {
            Size = UDim2.fromScale(1,1),
            BackgroundTransparency = 1,
            Text = "",
            ZIndex = 200,
        }, {})
        overlay.Parent = rootGui

        local popup = create("Frame", {
            Size = UDim2.new(0, btn.AbsoluteSize.X, 0, math.min(#options * 26, 150)),
            Position = UDim2.new(0, btn.AbsolutePosition.X, 0, btn.AbsolutePosition.Y + btn.AbsoluteSize.Y),
            BackgroundColor3 = Theme.panel2,
            ZIndex = 201,
        }, {})
        addCorner(popup, 8)
        addStroke(popup, Theme.stroke, 1, 0.5)
        popup.Parent = rootGui

        local scroll = create("ScrollingFrame", {
            Size = UDim2.new(1, 0, 1, 0),
            BackgroundTransparency = 1,
            ScrollBarThickness = 6,
            CanvasSize = UDim2.new(0, 0, 0, #options * 26),
            ZIndex = 202,
        }, {})
        scroll.Parent = popup

        local layout = Instance.new("UIListLayout")
        layout.Padding = UDim.new(0, 4)
        layout.Parent = scroll

        for _, name in ipairs(options) do
            local item = create("TextButton", {
                Size = UDim2.new(1, -8, 0, 24),
                BackgroundColor3 = Theme.control,
                Text = name,
                TextColor3 = Theme.text,
                Font = FONT,
                TextSize = 14,
                ZIndex = 203,
            }, {})
            addCorner(item, 6)
            item.Parent = scroll

            item.MouseButton1Click:Connect(function()
                selected[name] = not selected[name]
                item.BackgroundColor3 = selected[name] and Theme.accent or Theme.control
                updateStatus()
                if callback then callback(selected) end
            end)
        end

        overlay.MouseButton1Click:Connect(function()
            overlay:Destroy()
            popup:Destroy()
            openPopup = nil
        end)

        openPopup = popup
    end

    btn.MouseButton1Click:Connect(function()
        if openPopup then
            openPopup:Destroy()
            openPopup = nil
        else
            open()
        end
    end)

    return {
        Get = function() return selected end,
        Set = function(tbl)
            selected = tbl or {}
            updateStatus()
            if callback then callback(selected) end
        end
    }
end

            function sectionAPI:TextBox(placeholder, callback)
                local box = create("TextBox", {
                    Size = UDim2.new(1, 0, 0, 34),
                    BackgroundColor3 = Theme.control,
                    TextColor3 = Theme.text,
                    Font = FONT,
                    TextSize = 14,
                    PlaceholderText = placeholder or "",
                    ClearTextOnFocus = false,
                }, {})
                addCorner(box, 8)
                addStroke(box, Theme.stroke, 1, 0.5)
                box.Parent = stack

                box.FocusLost:Connect(function(enterPressed)
                    if callback then callback(box.Text, enterPressed) end
                end)

                return box
            end

function sectionAPI:TextBind(labelText, initKey, callback)
    local row = create("Frame", {
        Size = UDim2.new(1, 0, 0, 34),
        BackgroundTransparency = 1,
    }, {})
    row.Parent = stack

    local lbl = create("TextLabel", {
        Size = UDim2.new(0.7, 0, 1, 0),
        BackgroundTransparency = 1,
        Text = labelText,
        TextColor3 = Theme.text,
        Font = FONT,
        TextSize = 14,
        TextXAlignment = Enum.TextXAlignment.Left,
    }, {})
    lbl.Parent = row

    local keyBtn = create("TextButton", {
        Size = UDim2.new(0.3, -6, 1, 0),
        Position = UDim2.new(0.7, 6, 0, 0),
        BackgroundColor3 = Theme.control,
        TextColor3 = Theme.text,
        Font = FONT_B,
        TextSize = 14,
        TextXAlignment = Enum.TextXAlignment.Center,
        Text = (initKey and initKey.Name) or "RightShift",
    }, {})
    addCorner(keyBtn, 8)
    addStroke(keyBtn, Theme.stroke, 1, 0.5)
    keyBtn.Parent = row

    local bindKey: Enum.KeyCode = initKey or Enum.KeyCode.RightShift
    local recording = false

    keyBtn.MouseButton1Click:Connect(function()
        recording = true
        keyBtn.Text = "Press key..."
        keyBtn.BackgroundColor3 = Theme.accentDim
    end)

    UIS.InputBegan:Connect(function(input, gp)
        if gp then return end
        if recording and input.UserInputType == Enum.UserInputType.Keyboard then
            bindKey = input.KeyCode
            keyBtn.Text = bindKey.Name
            keyBtn.BackgroundColor3 = Theme.control
            recording = false
        elseif input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == bindKey then
            if callback then callback() end
        end
    end)

    return {
        SetBind = function(newKey)
            bindKey = newKey
            keyBtn.Text = bindKey.Name
        end
    }
end

function sectionAPI:ToggleColor(text, defaultState, defaultColor, callback)
-- добавить небольшой верхний отступ, чтобы не прилипать к заголовку under section
local spacer = create("Frame", {
    Size = UDim2.new(1, 0, 0, 12), -- можно 6..12 по вкусу
    BackgroundTransparency = 1,
}, {})
spacer.Parent = stack


    local row = create("Frame", {
        Size = UDim2.new(1, 0, 0, 34),
        BackgroundTransparency = 1,
    }, {})
    row.Parent = stack


    -- инлайновый toggle в этом же ряду
    local state = defaultState or false
    local box = create("TextButton", {
        Size = UDim2.new(0, 28, 0, 28),
        Position = UDim2.new(0, 0, 0, 3),
        BackgroundColor3 = state and Theme.accent or Theme.control,
        Text = "",
    }, {})
    addCorner(box, 6)
    addStroke(box, Theme.stroke, 1, 0.5)
    box.Parent = row

    local lbl = create("TextLabel", {
        Size = UDim2.new(1, -36-36, 1, 0), -- оставим место под кнопку цвета справа
        Position = UDim2.new(0, 36, 0, 0),
        BackgroundTransparency = 1,
        Text = text,
        TextColor3 = Theme.text,
        Font = FONT,
        TextSize = 14,
        TextXAlignment = Enum.TextXAlignment.Left,
    }, {})
    lbl.Parent = row

    -- кнопка цвета справа в том же ряду
    local colorBtn = create("TextButton", {
        Size = UDim2.new(0, 28, 0, 28),
        Position = UDim2.new(1, -32, 0, 3),
        BackgroundColor3 = defaultColor or Theme.accent,
        Text = "",
        ZIndex = 5,
    }, {})
    addCorner(colorBtn, 6)
    addStroke(colorBtn, Theme.stroke, 1, 0.5)
    colorBtn.Parent = row

    local function setToggle(newState)
        state = newState
        box.BackgroundColor3 = state and Theme.accent or Theme.control
        if callback then callback(state, colorBtn.BackgroundColor3) end
    end

    box.MouseButton1Click:Connect(function()
        setToggle(not state)
    end)

    colorBtn.MouseButton1Click:Connect(function()
        local rootGui = stack:FindFirstAncestorOfClass("ScreenGui")
        createColorPickerPopup(rootGui, colorBtn.BackgroundColor3, function(newColor)
            colorBtn.BackgroundColor3 = newColor
            if callback then callback(state, colorBtn.BackgroundColor3) end
        end)
    end)

    -- начальное уведомление
    if callback then callback(state, colorBtn.BackgroundColor3) end

    return {
        Set = function(s, c)
            setToggle(s)
            if c then colorBtn.BackgroundColor3 = c end
            if callback then callback(state, colorBtn.BackgroundColor3) end
        end,
        Get = function()
            return state, colorBtn.BackgroundColor3
        end
    }
end

function sectionAPI:ToggleDualColor(text, defaultState, c1, c2, callback)
-- добавить небольшой верхний отступ, чтобы не прилипать к заголовку under section
local spacer = create("Frame", {
    Size = UDim2.new(1, 0, 0, 12), -- можно 6..12 по вкусу
    BackgroundTransparency = 1,
}, {})
spacer.Parent = stack


    local row = create("Frame", {
        Size = UDim2.new(1, 0, 0, 34),
        BackgroundTransparency = 1,
    }, {})
    row.Parent = stack

    -- инлайновый toggle
    local state = defaultState or false
    local box = create("TextButton", {
        Size = UDim2.new(0, 28, 0, 28),
        Position = UDim2.new(0, 0, 0, 3),
        BackgroundColor3 = state and Theme.accent or Theme.control,
        Text = "",
    }, {})
    addCorner(box, 6)
    addStroke(box, Theme.stroke, 1, 0.5)
    box.Parent = row

    local lbl = create("TextLabel", {
        Size = UDim2.new(1, -36-68, 1, 0), -- оставим место под две кнопки справа
        Position = UDim2.new(0, 36, 0, 0),
        BackgroundTransparency = 1,
        Text = text,
        TextColor3 = Theme.text,
        Font = FONT,
        TextSize = 14,
        TextXAlignment = Enum.TextXAlignment.Left,
    }, {})
    lbl.Parent = row

    -- две кнопки цвета справа, в том же ряду
    local btn1 = create("TextButton", {
        Size = UDim2.new(0, 28, 0, 28),
        Position = UDim2.new(1, -64, 0, 3),
        BackgroundColor3 = c1 or Theme.accent,
        Text = "",
        ZIndex = 5,
    }, {})
    addCorner(btn1, 6)
    addStroke(btn1, Theme.stroke, 1, 0.5)
    btn1.Parent = row

    local btn2 = create("TextButton", {
        Size = UDim2.new(0, 28, 0, 28),
        Position = UDim2.new(1, -32, 0, 3),
        BackgroundColor3 = c2 or Theme.good,
        Text = "",
        ZIndex = 5,
    }, {})
    addCorner(btn2, 6)
    addStroke(btn2, Theme.stroke, 1, 0.5)
    btn2.Parent = row

    local function notify()
        if callback then
            callback(state, btn1.BackgroundColor3, btn2.BackgroundColor3)
        end
    end

    local function setToggle(newState)
        state = newState
        box.BackgroundColor3 = state and Theme.accent or Theme.control
        notify()
    end

    box.MouseButton1Click:Connect(function()
        setToggle(not state)
    end)

    local function openPicker(btn)
        local rootGui = stack:FindFirstAncestorOfClass("ScreenGui")
        createColorPickerPopup(rootGui, btn.BackgroundColor3, function(newColor)
            btn.BackgroundColor3 = newColor
            notify()
        end)
    end

    btn1.MouseButton1Click:Connect(function() openPicker(btn1) end)
    btn2.MouseButton1Click:Connect(function() openPicker(btn2) end)

    notify()

    return {
        Set = function(s, nc1, nc2)
            setToggle(s)
            if nc1 then btn1.BackgroundColor3 = nc1 end
            if nc2 then btn2.BackgroundColor3 = nc2 end
            notify()
        end,
        Get = function()
            return state, btn1.BackgroundColor3, btn2.BackgroundColor3
        end
    }
end

            return {
                Raw = sec,
                API = sectionAPI,
            }
        end

        local pageAPI = {}

        function pageAPI:AddUnderSections(leftName: string, rightName: string)
            local leftSec = makeSection(leftCol, leftName)
            local rightSec = makeSection(rightCol, rightName)
            return leftSec.API, rightSec.API
        end

        function pageAPI:SetNameOfMainSection(newName: string)
            -- Tab title is leftTitle when active
            tabs[tabName].button.Text = newName
        end

        return pageAPI
    end

    function api:SetHeader(leftText: string, rightText: string)
        leftTitle.Text = leftText
        rightTitle.Text = rightText
    end

    return api
end

return RoundedUI
